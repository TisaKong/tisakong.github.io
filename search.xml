<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>忙碌的2019,稳稳的2020</title>
      <link href="/2020/01/01/%E5%BF%99%E7%A2%8C%E7%9A%842019-%E7%A8%B3%E7%A8%B3%E7%9A%842020/"/>
      <url>/2020/01/01/%E5%BF%99%E7%A2%8C%E7%9A%842019-%E7%A8%B3%E7%A8%B3%E7%9A%842020/</url>
      
        <content type="html"><![CDATA[<p>刚刚过去的2019年，用一个词汇总结就是：忙碌。当然，在忙碌的环境里，个人成长也很大，不论是被迫的还是主动的。对于工作的思考，也上升了一个台阶。</p><p>年初搬进了公司的公租房里，住进了全新的两房一厅，除了阳台正对高速公路，轰轰轰的吵闹声之外，其他一切都很美好。每天早晨7点坐公司的班车，在车上看一个小时的电子书，到达公司才8点， 充裕的吃个早餐，还有大半个小时处理个人事务，关注学习新的技术。每天如此规律的生活，有时候让人一度认为，这样挺无聊的，总想着搞些事情才好。直到下半年发生了一些事情，才体会到，原来这种平淡规律的日子，是可遇不可求的。</p><p>2019年，生活上让人记忆深刻的事情屈指可数，也就是在上班途中完整的看完了几本书，包括技术类和文艺类的，记忆最深刻的是《笑傲江湖》，那段时间，每天早上和晚上都沉浸在这部大部头巨著中不可自拔。下班到家之后，绕着小区跑2圈5公里，这两件事情，构成了每日重复生活节奏中的两个主旋律。当然很遗憾的是，还有一些细枝末节的小事情， 因为没有写日记，已经被彻底遗忘在脑后了。</p><p>2019年，在工作中，随着平台业务量的剧增，事情也随之多了起来。各种合作方的对接联调，各种业务需求上的迭代改进，各种投诉工单问题的排查和处理，忙的不可开交。每日被各种各样的事情包围，撕碎了完整的时间。大家都知道，多线程是会耗用大量额外的系统资源的， 人脑也一样。在各种事情的不断切换之中， 做事情的效率就大打折扣了。所以有很长一段时间，我都感觉每天忙的连喝水的时间都没有， 但是每天下班后，却怎么都回忆不起，也讲不出这一天到底做了什么事情。当事情变得杂乱无章时，就更容易产生未知的问题，当各种问题累加在一起时，事情就更加剪不断，理还乱。</p><p>2019年，总的来说，就是在没有什么欲望，同时又忙忙碌碌中过去了，在人生的轨迹上，留下了不轻不重的一笔。</p><p>2020年刚到，我想为自己立个flag，在30岁这个人生新节点到来之前的最后一年时间里面，为自己20岁时期的人生画一个可圈可点的记号。</p><p>在工作中，学习更加有技巧的工作， 不要被琐事裹挟，偷走了时间，换回两手空空。将项目管理的理论知识用到实践当中，以事情的主导者的姿态面对工作，而不是被动’服从组织安排’。做好工作计划和工作总结，用时间管理四象限法则对事情进行归类，有条理的做事情。</p><p>在生活中，学会有趣。像对待专业一样去对待自己的兴趣，多尝试一些有趣的事情， 爬山、健身、跑步、学乐器；读书、写日记、写博客。关注美好的事情，记录美好的事情。多尝试，不为人生设限。</p><p>就像我博客的flag描述的：让成长的过程有迹可循。2020年，要让成长的过程有迹可循。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 个人成长 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我再次翻起那些尘封已久的记忆</title>
      <link href="/2019/11/10/%E5%9B%9E%E5%BF%86%E8%AE%A9%E6%88%91%E6%9B%B4%E5%8A%A0%E5%9D%9A%E5%AE%9A%E9%9D%A2%E5%AF%B9%E6%9C%AA%E6%9D%A5/"/>
      <url>/2019/11/10/%E5%9B%9E%E5%BF%86%E8%AE%A9%E6%88%91%E6%9B%B4%E5%8A%A0%E5%9D%9A%E5%AE%9A%E9%9D%A2%E5%AF%B9%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<p>周末的时光，过得分外的畅快，立冬后的广州，也丝毫感觉不到寒冷。 窗外阳光明媚，温度也刚好适中，暂且可以把繁重的工作扔到脑后。</p><p>偶然翻看手机相册，看到了过去一两年的旧照片，发现那时不经意定格的一张画面，偶然翻看，却是满满的回忆，脑海中就跟放电影似的，想起了那个时候在一起的伙伴和经历的事情。</p><p>想起自己还有个箱子，里面装的都是过去十年，从高中到大学的毕业照，各种证件，日记，索性就把它们全部捣腾出来，重新看看过去十年的自己…</p><p>十年前的自己，是数量不多的几张照片，照片也不知道是当时的那个谁，用的什么器材拍的，没有现在动不动就几千万像素的高画质，甚至还有些泛黄。但看到照片中的那些人，那些背景，突然有种莫名的感动。</p><p><img src="/images/memory/huoyup.jpg" alt=""></p><p><em>2007年高中远足活动，全校出动，统一校服，绵延不断几公里的队伍，壮观死了</em></p><p><img src="/images/memory/sdturti.jpg" alt=""></p><p><em>学校的大本钟，下面是我们的图书馆，高一高二学业不忙的时候，总是喜欢到图书馆去看看书，上上网</em></p><p><img src="/images/memory/dtfu.jpg" alt="">    </p><p>*还记得2008年的那场雪灾不，当时的我们，觉得那是天上降下来天使了，把我们激动坏了，打了几场雪仗，拍了好多照片。 *</p><p><img src="/images/memory/psuCAQPG196.jpg" alt="">    </p><p><em>高三元旦节，学校食堂专门给我们准备了一份大餐，加了鸡腿！</em></p><p><img src="/images/memory/psuCA0LBA1B.jpg" alt="">    </p><p><em>高三，某一个晚自习</em></p><p>还有好多好多张从高中到大学的不经意的定格画面，对我个人而言，都是宝贵的财富，有时间我就回头回味一下那些年的青春时光。</p><p>我也很庆幸，能在2012年开始写起了日记，那是最美的大学时光，转眼就7年过去了。日记写下的每一行字，虽然文辞不那么丰满，字里行间透出孩童般的幼稚，有时候为一些鸡毛蒜皮的小事伤心，有时候又因为某件事情激动的自己彻夜不眠，但现在读起来，还真是韵味无穷。</p><p>摘抄几段，让大家“欣赏欣赏”：</p><blockquote><p><strong>2012.04.21      胡想象          晴</strong></p><p>越来越发现厚黑的有效性。有话说过犹不及，但在有些事情上我们必须做到极致方能显现出它的价值，有的事情既然已经开始，并且不是错误的，我们就不应该半途而废，而是有始有终，做到极致。</p><p>书籍是个好东西，但很多东西根本不能从书中学到，那就是体验，任何事情自己不去亲身体验，永远不会明白它的真实道理，书中的东西只能给你带来处事的方向，多一些正确的感受，使你在经历的时候少走弯路。所以，要想真正理解体会一件事的含义和价值还是得亲身经历才行。</p></blockquote><p>这还是刚开始写日记的时候的第三篇，那个时候爱写一些大道理给自己听。文字都很浅显，而且都不能形成一个完整的论述，更像是一段心流，随心所欲的从心里流出的一段文字。</p><p>下面这篇也是，讲一个<code>不积跬步，无以至千里；不积小流，无以成江海</code>道理，整出一篇议论文。</p><blockquote><p><strong>2012年11月25日       雨</strong></p><p>学弹吉他大半年了， 还记得当初第一次拿起吉他拨弦时那种振奋的心情，羡慕别人能再简单的几根弦上拨出那么美妙的旋律。从此我开始不断地翻阅吉他吉他自学书籍，看吉他教学视频。《吉他自学三月通》被我翻了三遍，某些章节看了不下五遍。我开始对乐理知识有所了解和体会，能和别人谈关于乐理方面的知识了。</p><p>看吉他视频最大的好处就是能不断地激发你弹吉他的兴趣。你看到别人能将一首熟悉的曲子弹得那么动听，你也有跃跃欲试的感觉。有时候你也会失去兴趣，觉得也不过那么一回事儿，没什么意思，但是有时候很多东西就是在激发着你重新拿起吉他弹奏。一首乐曲需要重复弹很多遍才能熟练，一个简单的和弦连接你需要不断琢磨怎样圆滑地转换才能好听。</p><p>今天我突然从弹吉他这件事上认识到，一件事情，哪怕它很简单，你甚至都忽略它是如何存在的，但是突然的让你去处理一下，你恍然发现自己还真不会。就比如一件衣服，一双鞋，一个键盘，一个指甲剪，看上去多么不起眼，看上去它们好像天生就存在一样，可是让我们仔细琢磨一下它是怎么制造出来的，还真能让我感到束手无策。这就要谈到浮躁了，当今社会生活节奏加快，我们也深受影响，不知从什么时候开始，我们变得心浮气躁，什么事情都不能沉下心去做，要不认为这个我会，那个我也会，要不就认为这件事情做得没意义。于是宁愿无聊的坐一下午，这里逛逛，那里逛逛。</p><p>有很多东西，从短暂的时期看，没多大意义，但是，长远来看，却冥冥中改变着你，改变着周围的一切。为什么短短十几年就能塑造出一个人的性格，从一天天的生活来看，集体生活的两个人似乎没什么区别，就有些小小的行为不同，但是时间一积累，那区别就出来了。</p><p>一件事，不管什么，最经不住反复的去想去琢磨，去完成，积小成多。半年前，两个都不会弹吉他的，半年后一个人能弹出很多歌曲，一个人还是吉他都不知道怎么拿。区别的产生就在一天一天地积累中，一个人每天都在做，另一个人每天都在玩。</p><p>不积跬步，无以至千里；不积小流，无以成江海，就是这样。</p></blockquote><p>那时候的真的是，每件事情都能琢磨出一个道理来！</p><p>下面这篇是一首诗！那时候居然还能憋出一首诗来，哈哈哈！</p><blockquote><p><strong>2013年4月22日           雨             星期一</strong></p><p><strong>致我们已逝去的青春</strong></p><p>柳絮飘飞的季节</p><p>校园长椅短暂的停歇</p><p>仰望天空北飞的雁</p><p>思绪停泊到两年前</p></blockquote><blockquote><p>曾经臆想的大学校园</p><p>是多么的妙不可言</p><p>空气弥漫着爱情酝酿的蜜语甜言</p><p>知识和智慧在这片土地上长眠</p></blockquote><blockquote><p>可如今却时过境迁</p><p>爱情包裹着世俗的外衣</p><p>学生们在DOTA的世界勇往无前</p></blockquote><blockquote><p>飘落的柳絮遮住了眼</p><p>我迷失在这美丽的大学校园</p><p>我心中的在呐喊：</p><p>啊！德玛西亚！收了我吧！</p></blockquote><p>最后这句。。。 尬死我了。。。</p><p>还有歌词随想？</p><blockquote><p>有时候会彷徨</p><p>迈不开脚步向前方</p><p>内心时长会恐慌</p><p>不是艰难险阻太猖狂</p><p>而是没有穿上坚强的外衣裳</p><p>流过泪的眼睛才会明亮</p><p>受过伤的心灵才更坚强</p><p>看着爱的人的期待目光</p><p>鼓起勇气 背起行囊，一路向上</p></blockquote><p>好湿！好湿！</p><p>下面这篇，终于有一篇像日记的碎碎念了：</p><blockquote><p>2013年7月2日               星期二                晴</p><p>天又开始炎热了，又要开始找地方避暑了。昨天完成了第一次锻炼任务，跑了5公里，花了近半小时。拖着疲惫的身躯回到宿舍，心情大好。其实幸福挺简单嘛。</p><p>但是说实话，昨天一天的事件利用率还是很低的。上午十点多起床（怎么就那么多瞌睡），再一磨蹭，半小时过去了。背着书包就往高职走，到了才发现每个教室都有人在考试（what a fuck！），想来想去，算了吧，先去东南门买点东西吃，然后回宿舍睡个午觉（同学！你猜刚刚起床好伐！），下午再去自习。就这样，简简单单无聊了一中午，到了下午2:30，我毫不犹豫，背起书包直奔九号楼。在9201惊奇的发现居然还有那么多空位。找了一个地方坐下来。（好一个流水账）</p><p>网络技术确实是人类智慧的结晶，虽然看了半天糊里糊涂的，但比没看要强100倍了。网络告诉我，一切事物探寻其本质都是一个道理，解决问题都要一步一步来，从底层往高层走，就好比每个人都要吃饭，饭要一口一口的吃！</p><p>还是一句话：just do it！做永远比不做强！</p></blockquote><p>哎，有些道理，从我笔下出来，总感觉味道怪怪的，有股馊味。。。</p><p>上面是从日记本里随便摘入的几篇。后面还有很多，一直到2015年底， 2016年就没再手写日记了， 转为新浪博客。在新浪博客絮絮叨叨了3个月左右，就彻底没再记日记了。</p><p>今天再次翻看这些，不说眼眶突然湿润吧， 至少内心蔓延出一股了暖流，很感谢自己这些年，能记录下这些心路历程，保留下了成长的痕迹。人的一生很长，不奢望自己能在这个世界上带给他人多少能量，只期望不辜负自己的生命。而这些老照片，这些日记， 赋予我更多能量，让我在面对未知的道路上，不再孤单和害怕。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳日志实践</title>
      <link href="/2019/08/28/%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/08/28/%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>这篇博文是网易杭州研究院的员工总结出他们系统的日志输出规范，有较高的参考价值。</p><p>博文链接：<a href="https://zhuanlan.zhihu.com/p/27363484" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27363484</a></p><p>以下为内容提要，更详细的日志规范说明，可以参考博客原文。</p><h2 id="对好日志和坏日志进行定义和区分。"><a href="#对好日志和坏日志进行定义和区分。" class="headerlink" title="对好日志和坏日志进行定义和区分。"></a>对好日志和坏日志进行定义和区分。</h2><p>一句话，好日志能够快速让系统运维人员了解系统运行的状态，能快速定位系统的问题， 能发现系统存在的风险和系统的瓶颈所在。</p><h2 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h2><ul><li><strong>诊断日志</strong>： 请求响应，资源消耗，容错，程序异常，后台任务，启动配置参数等；</li><li><strong>统计日志</strong>： 用户访问统计；</li><li><strong>审计日志</strong>： 管理类的操作</li></ul><h2 id="日志内容"><a href="#日志内容" class="headerlink" title="日志内容"></a>日志内容</h2><ul><li><strong>原则</strong>：记录不多不少的信息。能合并为一条日志输出的，就不要输出多条。输出必要的信息，保证能快速定位到问题。</li><li><strong>通常会漏掉的日志</strong>：1）系统的配置参数；2）后台定时任务；3）异常处理逻辑；4）关键参数信息如失败原因等</li></ul><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><ul><li><strong>FATAL</strong>： 系统级别的错误，系统不可恢复的错误。一个进程生命周期最好只有一个FATAL类型日志。</li><li><strong>ERROR</strong>： 用户级别的错误，请求不能正常完成，需要人工介入处理。</li><li><strong>WARN</strong>： 系统潜在问题，比如资源即将消耗完，网络波动等，能不打warn日志就尽量不要打。</li><li><strong>INFO</strong>： 记录日志正常运行状态， 业务处理成功节点等。</li><li><strong>DEBUG/TRACE</strong>： 精确记录系统执行的每一步。</li></ul><h2 id="对日志的优化"><a href="#对日志的优化" class="headerlink" title="对日志的优化"></a>对日志的优化</h2><ul><li>日志需要持续优化</li><li>定期对系统的日志输出进行Review</li></ul><h2 id="请求的RequestID"><a href="#请求的RequestID" class="headerlink" title="请求的RequestID"></a>请求的RequestID</h2><ul><li>全链路跟踪</li><li>生成策略</li></ul><h2 id="日志级别的动态控制"><a href="#日志级别的动态控制" class="headerlink" title="日志级别的动态控制"></a>日志级别的动态控制</h2><ul><li>可以通过外部输入，控制部分日志的输出级别</li></ul><h2 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h2><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><ul><li>合理设置日志的报警，避免过多导致对报警失去敏感</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>日志文件分类：根据业务可以选择输出到不同的文件</li><li>日志文件大小：按日或按小时切割</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践分享 日志 标准化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>困难和机会总是相伴相随</title>
      <link href="/2019/07/09/%E5%9B%B0%E9%9A%BE%E5%92%8C%E5%87%A0%E4%B9%8E%E6%80%BB%E6%98%AF%E7%9B%B8%E4%BC%B4%E7%9B%B8%E9%9A%8F/"/>
      <url>/2019/07/09/%E5%9B%B0%E9%9A%BE%E5%92%8C%E5%87%A0%E4%B9%8E%E6%80%BB%E6%98%AF%E7%9B%B8%E4%BC%B4%E7%9B%B8%E9%9A%8F/</url>
      
        <content type="html"><![CDATA[<p>最近一个星期过的相当的艰难。一方面是团队的成员人数成倍的增长，给我们团队的管理和发展带来了新的挑战；另一方面是产品用户越来越多，对产品的质量和研发效率提出了更高的要求，等挑战到来的时候，才发现我们现在具备的能力还完全不足以应对。</p><p>随着工作经验的增长，团队对我的要求不再只是<code>只扫各自门前雪，不管他人瓦上霜</code>的状态了，习惯了只管领导分配的任务，完成细节处理就高枕无忧了，现在突如其来的既需要从全局的角度考虑问题，设计方案，又要处理细节上的问题，指导刚进入团队的新人熟悉项目的具体问题，可以说非得把一个人掰开成三个人来不可。一件事情就足以占满所有的时间，更不用说多件复杂度极高的事情叠加在一起了。</p><p>上周接到领导突如其来的一个任务，要求设计一个方案来解决与日俱增的摄像头云视频上传数，一天1000万数据量的业务，就快要拖死目前的平台架构了，所以必须设计一个好的方案来改进整个流程。一方面，只能说我的领导对他的上级交办的任务，也是力不从心的疲惫应付吧，他并没有很准确的传达他的领导的要求，导致我也不知道到底该怎么做。另一方面，也是我能力上的不足，即使我能充分理解上级的要求，可能也做不出一份合格的方案出来的。</p><p>对于团队规模的大量扩展，对我们老油条来说，不可不说是一个机会，因为可以有锻炼团队管理的机会了，手下几个小弟，怎么合理的分配任务，怎么有效的管理任务的进度，保证每次的需求都能及时并且高质量的完成。这些都是很好提升自我管理能力的机会。</p><p>当外部环境给你提出更多的要求的时候，怎么快速提升自己去满足这种要求，是不论到哪个公司，干什么种类的工作，都需要直接面对的问题。逃避解决不了问题。这种被迫成长的方式，很痛苦，但是承受这种痛苦，就不会有成长。遇到能力之外的问题，总想着逃避，就会陷入1年的经验反复用10年的陷阱里，发展到最后只会沦为被淘汰的境地。</p><p>面对问题，逐步分解问题，需要的资源自己想方法去获取，最终目的是要解决问题。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作态度 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么能让你立于不败之地</title>
      <link href="/2019/06/07/%E4%BB%80%E4%B9%88%E8%83%BD%E8%AE%A9%E4%BD%A0%E7%AB%8B%E4%BA%8E%E4%B8%8D%E8%B4%A5%E4%B9%8B%E5%9C%B0/"/>
      <url>/2019/06/07/%E4%BB%80%E4%B9%88%E8%83%BD%E8%AE%A9%E4%BD%A0%E7%AB%8B%E4%BA%8E%E4%B8%8D%E8%B4%A5%E4%B9%8B%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<p>一直在思考一个问题，就是人的什么能力，能够让人处在任何环境中，都能迅速适应，甚至有所作为。当然这个答案很简单，就是<strong>快速学习的能力</strong>。但是要掌握这个抽象的能力，却是比登天还难。</p><p>在生活中经常会发现这样的事情，就是跟自己一块学习的同学，有成绩特别突出的。渐渐的，也会发现，他不论在什么方面都会表现的很突出。他能快速掌握一个领域的知识，并准确的运用到实际的事情中。</p><p>导致他突出的原因可能有很多方面。</p><p><strong>一方面是智商</strong>。不得不承认，每个人的智商都是有差异的，有的人就是有过目不忘的能力，有的人的罗辑思维能力很强，能够快速梳理一个陌生领域的知识体系。</p><p><strong>一方面是意志力</strong>。意志力强的人，对待陌生领域的知识，能够长时间的专注的去研究，并不断地试错。试错的过程，对一般人来说可能是一个极度痛苦的过程，但是对意志力强的人来说，这是一种享受，他能弱化试错带来的痛苦，强化它带来的成效。</p><p>快速学习的能力能不能学习得到？如果能，我想也只能通过提高智商和意志力这两个方面入手。</p><p><strong>智商怎么锻炼？</strong>需要不停主动思考。怎么主动思考？先从提出问题开始，提出一个问题，就必定要去思考这个问题的答案，就会去主动寻找，通过主动阅读，关联，归纳等等方法，最终给自己一个满意的解答，这一系列的主动过程，就是在有意识的锻炼自己的智商的过程。</p><p><strong>意志力怎么锻炼？</strong>每日坚持干看上去简单的事情，重复的干简单的事情。简单的事情干的多了之后，总会产生厌烦的情绪，控制住这种情绪，坚持下去，在重复的过程中体会从量变到质变的过程，从重复的过程中，总结出不重复的经验，渐渐消减厌烦的情绪。</p><p>其实，这两种锻炼，都是在不断地让自己<strong>逃离舒适区</strong>的方法。不断地干自己不会的，干到自己会，就是这么一个过程。</p><blockquote><p> 痛苦-&gt;领悟-&gt;痛苦-&gt;领悟。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的读书实践论</title>
      <link href="/2019/05/03/%E6%88%91%E7%9A%84%E8%AF%BB%E4%B9%A6%E5%AE%9E%E8%B7%B5%E8%AE%BA/"/>
      <url>/2019/05/03/%E6%88%91%E7%9A%84%E8%AF%BB%E4%B9%A6%E5%AE%9E%E8%B7%B5%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="读书的目的"><a href="#读书的目的" class="headerlink" title="读书的目的"></a>读书的目的</h2><p>只读书，不思考，不实践，很多东西就只是浮于表面，没有真正理解，也就不能学以致用。</p><p>一切不以实践为目的的读书，都是耍流氓。</p><p>以实践为指导来读书，就会发现大部分书，书中的一半以上的文字，都是在说废话，另一半才是真正在指导实践中有意义的知识。读书就是重复地甄别出那部分糟粕，取出其中有利于实践的精华，并加以总结和运用，最后内化为自身的一种能力。</p><p>效率则是检验读书是否有效的转化为实践的一种度量方式。要想有高效率，就必须在做事情之前设立一个明确的目标，以达到目标为指向，才能明确自己是否真的在做有意义的事情。</p><p>所以读书之前也要先设定一个目标，为何要读书，读这本书要解决你什么疑惑，读完之后是否解决了疑惑，能否将读书中学到的知识转化为实践，解决之前遇到的难题？</p><h2 id="可持续目标"><a href="#可持续目标" class="headerlink" title="可持续目标"></a>可持续目标</h2><p>前面说做事情之前要制定目标，没有目标就没有方向和进度，也就没有效率。其实，目标还需要有一个可持续的特性，制定一个不可持续的目标，进度就会终止，做事情就不会一直往更好的方向发展。</p><p>比如要学习一门新的编程语言，如果只是把读完一本《***从入门到精通》作为学习的终极目标，那基本上永远都学不会这门编程语言。但也不能一次把目标定的过于宏大。比如要完成编写像Windows一样的操作系统，虽然这并不是一个不可达到的目标，但是可以肯定，这是一个短期内不可能达到的目标。</p><p>人总是因为走的太远太久，而忘记了出发时的初衷。当目标过于宏大的时候，需要拆解为N个阶段性的目标，作为一段时间段内的终极目标。比如要写出windows一样的操作系统，首先需要理解已经存在的操作系统它的工作原理和机制，它的功能特性，还要理解这些功能特性它是如何实现的，它解决了什么问题…等等，依次拆分下去，直到最终每一个目标变成一个能够切实可行的工作计划，知道最终要从哪里开始下手，知道怎样才算是完成了一个阶段性的目标。</p><p>所以总结下来就是：</p><blockquote><p>要完成一件事情，首先要思考，这件事情到底是什么东西(What)，做这件事情的目的是什么(Why)，要完成它该如何下手(How)，这就涉及到大事情的拆分，拆分成切实可行的小目标，然后对小目标立一个里程碑(When)，什么时候要完成这个里程碑，要给自己一些压力，最终完成这件事情，达到一个目标(How feel),人生得到了升华。最后不断的循环往复，找到目标，不断实现目标，实现终极价值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出才是王道</title>
      <link href="/2019/01/09/%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%B6%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%BA%8B/"/>
      <url>/2019/01/09/%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%B6%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>输出是一件困难的事情。</p><p>在最近2年的工作生活中，一直在不断地探索，如何将日常生活中的观察到的事件，亲身体验到的感受，在书本中阅读到的知识，内化到自己的大脑中。</p><p>这一内化的过程太困难，实践起来太痛苦，以至于每次想动笔开始输出的时候，总是不知道从何开始，或者即使动笔写了两段，发现内容太过枯燥、低级，输出的东西根本不是自己想象中的。这一过程也就在短暂的尝试之后，戛然而止。</p><p>我曾经还是有过一段输出的比较顺畅的时候的，虽然内容在现在看来显得很幼稚和浅薄，但那部分内容，都是自发的、主动的从大脑中流出的，以后来看，也会成为一段最为真实和珍贵的回忆。</p><p>我上周看了一本季羡林大学时期的日记，整本书都是每日活动之总结，吃喝拉撒睡，读书，写作，与人交谈，国学大师也不可能每天变换花样的描述自己的日常生活，没有人每天都能过的像演电影似的精彩纷呈，生活的大部分时间都是平淡的，重复的。</p><p>既然日子本身就是那样平淡，又怎么能希冀一个普通人，能每天输出精彩纷呈的现实生活呢？除非是虚构，除非是绞尽脑汁的创作。</p><p>这种虚构和创作的过程，就跟编程是一回事。首先得有需求，其次还得设计，然后才是编码实现，最后还得反复测试修改，最终成品。</p><p>这样想来，平时我觉得写作输出是一件困难无从下手的事情，即使创作出来，作品也是劣质的，没有营养的原因，就在于没有找到创作真正的过程–跟编程一样的过程。大部分时候，我写作，都省略了获取需求、设计、测试修改的过程，只希望快速编码实现成品。就跟刚开始学习编程一样，最终得到的产品质量就可想而知了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 设计模式 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 中的动态代理</title>
      <link href="/2018/01/23/java%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2018/01/23/java%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章是关于<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">java动态代理的</a>，它是 java 语言提供给我们主要的代理机制。</p><p>简单的说，代理就是使用自己定义的方法，包装原始对象的方法调用，在自己的方法中可以做一些额外的事情。用户直接使用代理对象完成业务请求。</p><p>动态代理允许一个具有单个方法的类为任意数量的方法对任意类进行多个方法调用。动态代理可以看做是一个「Facade」模式，但是也可以包装成一个接口的实现。在这两种特性之下， 它可以将所有方法的调用路由到某一个方法 <code>invoke()</code> 中。</p><p>代理并不常用于一些日常的开发任务的。动态代理经常用于框架的编程，或者只有在运行时才能确定具体的类实现的场景中。</p><p>此特性内置于标准的 JDK 中，因此不需要额外的依赖项。</p><h2 id="Invocation-Handler"><a href="#Invocation-Handler" class="headerlink" title="Invocation Handler"></a>Invocation Handler</h2><p>首先来构建一个简单的代理，除了打印请求调用的方法之外，实际上什么也不做，并返回一个硬编码的数字。</p><p>首先创建一个实现了 <code>java.lang.reflect.InvocationHandler</code> 接口的的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = Logger.getLogger(<span class="string">"DynamicInvocationHandler"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"invoke method &#123;&#125; "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个简单的代理，日志输出哪个方法被调用了，并且返回1。</p><h2 id="创建-proxy-实例"><a href="#创建-proxy-实例" class="headerlink" title="创建 proxy 实例"></a>创建 proxy 实例</h2><p>现在通过类 <code>java.lang.reflect.Proxy</code> 类的工厂方法 <code>newProxyInstance()</code> 创建刚刚定义的 <em>InvocationHandler</em> 类实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map map = (Map) Proxy.newProxyInstance(Main<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), </span></span><br><span class="line">                    new Class[]&#123;Map.class&#125;, </span><br><span class="line">                    <span class="keyword">new</span> DynamicInvocationHandler());</span><br><span class="line">        map.put(<span class="string">"some"</span>, <span class="string">"stuff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>一月 23, 2018 11:53:54 上午 com.proxy.DynamicInvocationHandler invoke</p><p>信息: invoke method {} put</p></blockquote><h2 id="通过-lambda-表达式实现-InvocationHandler"><a href="#通过-lambda-表达式实现-InvocationHandler" class="headerlink" title="通过 lambda 表达式实现 InvocationHandler"></a>通过 lambda 表达式实现 InvocationHandler</h2><p>由于 <code>java.lang.reflect.InvocationHandler</code> 是一个函数式接口，可以使用lambda表达式直接定义一个 Invocation Handler 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Proxy.newProxyInstance(Main<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), </span></span><br><span class="line">new Class[]&#123;Map.class&#125;, </span><br><span class="line">(Object proxy, Method method, Object[] args) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"get"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported method: "</span> + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main2()</code> 方法中，定义了一个 InvocationHandler ,如果 <code>get()</code> 方法被调用，则返回1，否则抛出 <em>UnsupportedOperationException</em> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object some = map.get(<span class="string">"some"</span>);</span><br><span class="line">System.out.println(some);</span><br><span class="line">map.put(<span class="string">"some"</span>, <span class="string">"stuff"</span>);</span><br></pre></td></tr></table></figure><p>返回结果：</p><blockquote><p>23</p><p>Exception in thread “main” java.lang.UnsupportedOperationException:<br>Unsupported method: put</p><p>at com.proxy.Main.lambda$main2$0(Main.java:22)</p><p>at com.sun.proxy.$Proxy0.put(Unknown Source)</p><p>at com.proxy.Main.main2(Main.java:29)</p><p>at com.proxy.Main.main(Main.java:12)</p></blockquote><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>有这样一个应用场景，假设我们想记录下我们的方法的调用耗时，此时我们先定义一个Invocation Handler,来包装我们的真实对象，即：<em>target</em> 对象，通过反射获取到 target 对象的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingDynamicInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = Logger.getLogger(<span class="string">"TimingDynamicInvocationHandler"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Method&gt; methods = <span class="keyword">new</span> HashMap&lt;String, Method&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimingDynamicInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">for</span> (Method method : target.getClass().getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.methods.put(method.getName(), method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">        Object result = methods.get(method.getName()).invoke(target, args);</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">        LOGGER.info(<span class="string">"Executing "</span> + method.getName() + <span class="string">"finished in "</span> + elapsed + <span class="string">"ns"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后,这个代理可以被运用于各种对象类型中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingDynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代理HashMap对象</span></span><br><span class="line">        Map mapProxyInstance = (Map) Proxy.newProxyInstance(TimingDynamicProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), </span></span><br><span class="line">new Class[]&#123;Map.class&#125;, new TimingDynamicInvocationHandler(new HashMap&lt;&gt;()));</span><br><span class="line">        mapProxyInstance.put(<span class="string">"some"</span>, <span class="string">"something"</span>);</span><br><span class="line">        Object some = mapProxyInstance.get(<span class="string">"some"</span>);</span><br><span class="line">        System.out.println(some);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理CharSequence对象</span></span><br><span class="line">        CharSequence helloWorld = (CharSequence) Proxy.newProxyInstance(TimingDynamicProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), </span></span><br><span class="line">new Class[]&#123;CharSequence.class&#125;, new TimingDynamicInvocationHandler("hello world"));</span><br><span class="line">        <span class="keyword">int</span> length = helloWorld.length();</span><br><span class="line">        System.out.println(length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容为：</p><blockquote><p>一月 23, 2018 2:39:00 下午 com.proxy.TimingDynamicInvocationHandler invoke</p><p>信息: Executing “put” finished in 17728ns</p><p>一月 23, 2018 2:39:00 下午 com.proxy.TimingDynamicInvocationHandler invoke</p><p>信息: Executing “get” finished in 10575ns</p><p>一月 23, 2018 2:39:00 下午 com.proxy.TimingDynamicInvocationHandler invoke</p><p>信息: Executing “length” finished in 6531ns</p><p>something</p><p>11</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的例子，简单的介绍了 java 动态代理的使用方法和可能的应用场景。这些场景更多的使用在框架的设计之中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java动态代理 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写python的91个建议（未完）</title>
      <link href="/2018/01/23/%E7%BC%96%E5%86%99Python%E7%9A%8491%E4%B8%AA%E5%BB%BA%E8%AE%AE/"/>
      <url>/2018/01/23/%E7%BC%96%E5%86%99Python%E7%9A%8491%E4%B8%AA%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>我看专业类的书籍有一个癖好，就是喜欢翻它扉页上面的出版日期，如果出版日期距离现在有了5年以上的时间了，那我对这本书的兴趣也少了不少，虽然很多时候是冲着书名去的。但是技术发展这么快，每年都有大量新的技术，新的思想出现，所以除了那种公认的经典技术书籍，一般过了5年的时间，书中所描述的技术也很可能已经过时了。</p><p>之前翻过跟代码质量有关的经典书籍如：《重构，改善代码原有的设计》，《代码大全》,《代码整洁之道》等等，这类书籍真是看一遍就受益匪浅。但仅仅看一遍呢，印象也并不怎么深刻，当时没做笔记，看过的内容都已经忘记的差不多，在实践过程中，虽然能偶尔想起书中所描述的只言片语，但最终还是不能够信手拈来的按照大师们的理论来指导自己编码。所以看书，特别是专业书，做笔记，回顾是必要的课程。</p><p>今天开始看的这本书叫《编写高质量的代码，改善python程序的91个建议》。最近对怎么写出质量高，颜值也高的代码非常有兴趣，但是代码的质量跟写代码的多少有直接的关系，但同时也不能不借鉴前人总结出的经验，站在巨人的肩膀上望一望。</p><p>虽然没学过python，但语言只是工具，绝大部分编程语言都大同小异。就像倚天屠龙记里张无忌学会了九阳神功之后，天底下的其他武功绝学，在他看来都是小儿科一样。写代码也是一样的道理咯，最重要的还是思想。</p><p>作者提出了91条编写python的建议，每一条都非常精简的概括出要义，非常容易理解。前三条是要我们在写python的时候，能够写出具有python独特风格的pythonic的代码。那什么是pythonnic的代码？ 一句话：只可意会不可言传。更具体的，当你在控制台输入python，进入python的命令行交互界面，并输入指令：<code>import this</code> 的时候，你会看到如下的一首诗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&apos;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&apos;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&apos;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&apos;s do more of those!</span><br></pre></td></tr></table></figure><p>用精简的中文翻译就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python之禅</span><br><span class="line">美胜丑，显胜隐，简胜杂，杂胜乱，平胜陡，疏胜密。</span><br><span class="line">找到简单问题的一个方法，最好是唯一的方法。</span><br><span class="line">难以解释的实现，源自于不好的主意；如果有非常好的主意，那它肯定易于解释。</span><br></pre></td></tr></table></figure><p>用一句话总结pytonic的代码，那就是充分利用python的独特语法特性和库特性，遵从业界公认的好的代码风格，写出简洁易懂的代码。</p><p>接下来第4,5个建议是关于代码注释和让代码看上去整洁的建议。需要对注释有正确的理解。注释太多和太少都不是好主意。注释是对代码的补充，不能让注释成为对代码的翻译，也不能让注释对代码产生歧义。在代码间适当的添加空行，会有利于代码的阅读。一组代码表达完一个完整的思路后，最好用空行进行间隔。现代代码编辑工具都是集成环境(IDE)，它内部集成了比较良好的代码格式化工具。充分利用好IDE的功能，是一个不错的选择。</p><p>第6个建议是关于编写函数的。作者罗列了4个原则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原则一：函数设计要尽量短小，嵌套层次不宜过深。</span><br><span class="line"></span><br><span class="line">原则二：函数的申明应该做到合理简单，易于使用。</span><br><span class="line"></span><br><span class="line">原则三：函数的设计应该经过深思熟虑，考虑到向下兼容。</span><br><span class="line"></span><br><span class="line">原则四：一个函数只做一件事情。</span><br></pre></td></tr></table></figure><p>这四条编写函数的原则，是独立于语言的，它对任何语言编写的程序来说，都是适用的准则。是一种思想。这里要解释一下原则四，何为只做一件事情？我们必须要有一个参照基准，那就是在同一个抽象层级上面，所有语句尽量在同一个粒度上。</p><p>第7个建议是将常量集中到同一个文件之中，常量的命名最好全大写表示。这个比较好理解，放在同一个文件中，修改起来更容易寻找。</p><p>第8个建议是正确的使用断言(assert))。断言会对性能有影响，因此不要滥用断言，断言应该使用在正常逻辑不可到达的地方或者正常情况下总是为真的场景。像数组越界，类型不匹配，处理用户输入等异常时不适合用断言。</p><p>第9个建议是特定与python语法的，就是数据交换时，不推荐使用中间变量值。而是这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y = y,x;</span><br></pre></td></tr></table></figure><p>第10条建议很有意思，是说充分利用延迟计算的特性。什么是延迟计算，其实很多语言都有这个特性，就是条件表达式中，<code>if x and y</code> ,当x为false的时候，y表达式的值将不再计算；<code>if x or y</code> ，当x的值为true时，将直接返回，不再计算y的值。巧妙的运用这一特性，可以在某些场合提高程序的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 下使用 jenkins 打包部署 web 项目</title>
      <link href="/2017/12/21/windows%E4%B8%8B%E4%BD%BF%E7%94%A8jenkins%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/12/21/windows%E4%B8%8B%E4%BD%BF%E7%94%A8jenkins%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>首先有必要解释下现代软件开发领域的基石 <em>Continuous Integration(CI)</em>。「<strong>持续集成</strong>」是一个监视版本控制系统改变的软件，每当发生变化，这个工具会自动编译并测试你的应用。如果发生错误，会及时的通知到开发者，让开发者第一时间修复问题。同时，它还能自动的检测代码的质量和测试的覆盖率。jenkins 就是这样一种工具。</p><h2 id="jenkins-安装（windows-平台）"><a href="#jenkins-安装（windows-平台）" class="headerlink" title="jenkins 安装（windows 平台）"></a>jenkins 安装（windows 平台）</h2><p>jenkins 在 windows 平台的安装相当简单，跟普通的 windows 桌面应用程序一样 ，去 [link] <a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a> 下载 windows 平台的安装包(以 .msi 结尾)。</p><p>安装完成后，jenkins 会作为一个 Web 服务(在系统的计算机管理-服务与应用程序-服务中查看)常期运行。通过在浏览器输入 <code>localhost:8080</code> 访问 jenkins 的 web 界面。</p><h2 id="修改默认绑定的端口"><a href="#修改默认绑定的端口" class="headerlink" title="修改默认绑定的端口"></a>修改默认绑定的端口</h2><p>jenkins服务会自动默认占用 8080 端口，如果想修改这个默认端口， 在 jenkins 的安装目录找到 jenkins.xml 修改 <code>--httpPort=8080</code> ，变成你需要的端口。</p><p>jenkins.xml 文件可能提示无权限修改，则需要先将 jenkins.xml 的权限修改为可写(右键-属性-安全-编辑)。修改完成需要重启服务：以管理员身份打开命令行窗口，输入 <code>net stop jenkins</code> , 等待服务停止成功后，再输入 <code>net start jenkins</code> 等待服务启动。</p><p>首次登陆 jenkins 会进入 <em>Unlock Jenkins</em> 步骤，按照它说明的要求完成就可以进入首页界面了。</p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>首次进入 jenkins , 进入「系统管理 - Global Tool Configuration」对各种环境进行配置，主要包括：</p><ul><li>JDK</li><li>Git</li><li>Maven</li></ul><p>这些配置都可以使用本地环境已经安装好的软件，也可以让 jenkins 为我们从网上下载安装。</p><h2 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h2><p><strong>新建一个自由风格的软件</strong> ，对任务进行配置，主要包括：</p><ul><li>General</li><li>源码管理</li><li>构建触发器</li><li>构建环境</li><li>构建</li><li>构建后的操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续集成 jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习使用Git &lt;上篇&gt;</title>
      <link href="/2017/10/30/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8git/"/>
      <url>/2017/10/30/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8git/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前很多传统的互联网公司还是使用 <code>SVN</code> 作为常用的版本控制工具(CVS)，<code>SVN</code> 属于<u><strong>集中式版本控制系统</strong></u>，团队协作开发中的每个成员都是共享网络服务器上存储的同一份项目代码，任何代码的更新和提交操作都需要在有网络的前提下进行。<br><code>git</code> 属于<u><strong>分布式版本控制系统</strong></u> ，它把远程代码仓库完整的镜像拷贝到本地，这样使得每一个开发者的本地也有一个与远程服务器上相同的仓库。这样任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。</p><hr><h1 id="使用git前的配置"><a href="#使用git前的配置" class="headerlink" title="使用git前的配置"></a>使用git前的配置</h1><h2 id="git-config工具"><a href="#git-config工具" class="headerlink" title="git config工具"></a><strong>git config</strong>工具</h2><p>使用：git config  [选项] [参数]<br>说明：[选项]有三种模式：<br>            <code>--system</code> ：对系统中所有用户适用的配置，操作的是<u>/etc/gitconfig</u>文件(linux系统下) 或者 <u>Git安装目录/gitconfig</u>文件。<br>            <code>--global</code> ：只适用当前用户的配置，操作的是<u>用户目录/.gitconfig</u>文件。<br>            <code>不带参数</code> ：当前项目的Git目录中的配置文件，<u>.git/config</u>文件。<br>      [参数] 可以通过 <code>git config --list</code> 查看所有已配置的参数信息，会输出类似下面的信息：</p><blockquote><p>user.name=tisakong<br>user.email=tisakong@163.com<br>help.format=html<br>color.diff=auto<br>core.symlinks=false<br>…</p></blockquote><h2 id="配置用户信息（用户名、email）"><a href="#配置用户信息（用户名、email）" class="headerlink" title="配置用户信息（用户名、email）"></a><strong>配置用户信息（用户名、email）</strong></h2><p>目的：git在提交时会引用用户信息，来说明是谁提交了更新，相当于是开发者的身份信息。会随着更新的内容一起被放入历史记录中。<br>配置命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name tisakong</span><br><span class="line">git config --global user.email tisakong@163.com</span><br></pre></td></tr></table></figure><p>当然，也可以只对当前工作目录配置单独的用户信息，只需要去掉 <code>--global</code> 选项即可，这样该工作目录下的提交信息，Git就会用单独配置的用户信息来记录了。</p><h2 id="配置文本编辑器-和-差异分析工具"><a href="#配置文本编辑器-和-差异分析工具" class="headerlink" title="配置文本编辑器 和 差异分析工具"></a><strong>配置文本编辑器 和 差异分析工具</strong></h2><p>当 git 需要你输入额外消息的时候，会调用一个外部文本编辑器给你使用（比如在使用git commit提交更新的时候，会调用编辑工具让用户输入注释说明），默认指定系统的默认编辑器，通过参数配置自己偏好的编辑器（如vi、vim、Emacs等）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor Emacs</span><br></pre></td></tr></table></figure><p>在合并冲突时指定使用哪种差异分析工具，常用的有： <code>kdiff3</code>，<code>tkdiff</code>，<code>meld</code>，<code>xxdiff</code>，<code>emerge</code>，<code>vimdiff</code>，<code>gvimdiff</code>，<code>ecmerge</code> 和 <code>opendiff</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure><h2 id="git-help"><a href="#git-help" class="headerlink" title="git help"></a>git help</h2><p>当然，使用 <code>git help</code> 命令可以方便的查看有哪些 git 命令可以使用。<br>使用 <code>git help &lt;命令&gt;</code> 可以调起 Git 提供的帮助文档，方便查看具体的命令的使用说明。</p><hr><h1 id="git-基本操作"><a href="#git-基本操作" class="headerlink" title="git 基本操作"></a>git 基本操作</h1><p>本小节说明 Git 的本地操作，包括：</p><blockquote><ul><li>创建和克隆仓库</li><li>暂存和提交修改</li><li>查看历史修改记录</li></ul></blockquote><h2 id="获取-git-仓库"><a href="#获取-git-仓库" class="headerlink" title="获取 git 仓库"></a>获取 git 仓库</h2><p>有两种方法获取git仓库：</p><blockquote><ol><li>从工作目录创建新的 git 仓库</li></ol></blockquote><p>在当前工作目录中执行 <code>git init</code> 命令，当前目录会生成一个 <code>.git</code> 目录，此时完成了对所有<em>文件和目录</em>的初始化工作。</p><blockquote><ol start="2"><li>从现有仓库中克隆</li></ol></blockquote><p>使用 <code>git clone [url]</code> 命令，该动作会将<code>[url]</code>指向的仓库项目的所有的历史数据(每个文件的所有版本)拷贝到本地。</p><h2 id="Git管理文件的几种状态及操作"><a href="#Git管理文件的几种状态及操作" class="headerlink" title="Git管理文件的几种状态及操作"></a>Git管理文件的几种状态及操作</h2><p>工作目录下的所有文件，存在两种状态：<strong>未跟踪(Untracked)</strong> 和 <strong>已跟踪(tracked)</strong>。</p><h3 id="使用-git-status-命令查看目录下文件的状态。"><a href="#使用-git-status-命令查看目录下文件的状态。" class="headerlink" title="使用 git status 命令查看目录下文件的状态。"></a>使用 <code>git status</code> 命令查看目录下文件的状态。</h3><p><strong>未跟踪</strong> 是指在本地新增或修改了的文件，还没有使用过 <code>git add</code> 被 Git 管理。 </p><p>未跟踪的文件会被列在：</p><ul><li>Untracked files : 表示本地未被 Git 管理的文件</li></ul><p><strong>已跟踪</strong> 是指已被执行过 <code>git add</code> 命令，在<em>当前缓存区域</em>中，或者 Git 记录了<em>上次更新的快照</em>。</p><p>已跟踪的文件存在2种状态：</p><ul><li><p>Changes not staged for commit : 表示在本地有修改，但没有推到缓存区域中的文件</p></li><li><p>Changes to be committed : 表示在本地有修改，并且已经通过 <code>git add</code> 推到缓存区域中的文件</p></li></ul><h3 id="被忽略的文件"><a href="#被忽略的文件" class="headerlink" title="被忽略的文件"></a><strong>被忽略的文件</strong></h3><p>可以在工作根目录下创建 <strong>.gitignore</strong> 文件，来定义不需要被 Git 管理，也不用出现在未跟踪列表中的文件。<br>通常，需要被忽略的文件一般为：</p><blockquote><ul><li>自动生成的文件</li><li>日志文件</li><li>临时文件等</li></ul></blockquote><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a><strong>提交更新</strong></h3><p>使用 <code>git commit -m &#39;注释说明&#39;</code>，将缓存区域的文件提交，让Git生成快照。 </p><p><strong>跳过缓存区域直接提交文件</strong><br>Git 提供一种方式——使用 <code>git commit -a -m &#39;注释说明&#39;</code>，可以一次性将本地修改的文件和缓存区域的文件全部提交。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h3><p>分为两种情况：</p><blockquote><ol><li>在本地删除文件，使用 <code>rm</code> 命令。<br>使用这种方式删除被Git跟踪的文件，只是删除了本地文件，要删除Git本地仓库中的文件，还需要使用 <code>git add .</code> 提交到缓冲区和<code>git commit</code> 提交命令。</li></ol></blockquote><blockquote><ol start="2"><li>使用 <code>git rm</code> 命令<br>使用这种方式，则只需要使用 <code>git commit</code>提交，即可删除Git本地仓库中的文件。</li></ol></blockquote><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a><strong>移动文件</strong></h3><p>和删除文件类似。使用 <code>git mv file_from file_to</code> 移动本地和缓存区文件，使用<code>git commit</code>将改动提交到本地仓库。</p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>使用 <code>git log</code> 命令按照提交时间列出所有的更新。除此之外，它还提供很多选项，来对历史记录进行定制输出,详细信息可以使用 <code>git log --help</code> 进行查看学习。</p><p>Git 还自带图形化工具用于查阅提交历史，通过使用 <code>gitk</code> 调起图形化界面。</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>根据Git管理文件的3个阶段，撤销操作也可以看做在三个阶段进行：</p><blockquote><p> <strong>修改最后的提交(commit)操作</strong></p></blockquote><p>应用场景：在提交完之后，发现遗漏了部分文件没有添加，或者提交的信息写错了。<br>使用方法示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;init commit&apos; //初始提交（发现有更改的文件还没有add）</span><br><span class="line">git add forgotten_file  //将更改的文件add进去</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>第一个提交补充了更改了为添加的文件，并且修正了第一次提交的内容。</p><blockquote><p> <strong>撤销已暂存(add)的文件操作</strong></p></blockquote><p>使用 <code>git reset HEAD &lt;file&gt;...</code> 将暂存区的文件撤回，也就是将放进 <code>Changes to be committed:</code> 中的文件，放入 <code>Changes not staged for commit:</code> 中。</p><blockquote><p> <strong>取消对文件的修改</strong></p></blockquote><p>此操作的含义是用最近提交的文件来覆盖本地的文件，相当于SVN的<code>revert</code>操作。使用 <code>git checkout -- &lt;file&gt;...</code> 命令完成操作。该操作具有一定的风险。在进行操作时，务必确保不需要保留刚才的修改。</p><h1 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h1><p><strong>含义：</strong> 远程仓库指的是托管在网络上的项目仓库，同一个项目可以具有<em>多个</em>远程仓库，并且具有可读可写的权限控制。在同别人合作开发时，需要管理这些远程仓库，通过推送(<code>push</code>)和拉取(<code>pull</code>)数据，分享各自的工作进展。<br>管理远程仓库的工作包括：</p><blockquote><ul><li>添加远程仓库</li><li>移除/废弃远程仓库</li><li>管理远程仓库的<strong>分支</strong></li><li>跟踪分支等</li></ul></blockquote><h2 id="查看当前远程库"><a href="#查看当前远程库" class="headerlink" title="查看当前远程库"></a>查看当前远程库</h2><p>查看当前配置有哪些远程仓库，使用<code>git remote</code>命令，它会列出每个远程库的简短名称（命令加上<code>-v</code>选项，则显示仓库对应的克隆地址）。首次克隆完某个项目后，至少可以看到一个名称为<strong>origin</strong>的远程库，Git默认使用该名来标识你说克隆的原始仓库。如果有多个仓库地址，也会全部列取出来。</p><p><strong>添加远程仓库：</strong> 使用<code>git remote add [shortName] [url]</code>命令。该命令的含义是：将<code>url</code>对应的远程仓库添加到本地配置中，并且为它取一个别名<code>shortName</code>。以后就可以使用<code>shortName</code>指代对应仓库的地址了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git 版本控制 工具 读书 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 与 java 核心语法的对比学习</title>
      <link href="/2017/06/29/python%E4%B8%8Ejava%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/06/29/python%E4%B8%8Ejava%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>大部分程序设计语言在基本语法上面大致都是相通的，根据已掌握的语言对比学习一门新的语言，将是一个高效的学习方式。在学习新语言的时候，只需要重点关注和记忆它<strong>特有的语言特性</strong>，并在实践中多加运用，然后再深入学习它的<strong>组件、框架</strong>等内容，想必是可以快速掌握这门新的语言的。</p><p>下面是本人在新接触<strong>python</strong>这门语言的时候，与<strong>java</strong>的简单对比学习的笔记内容，目标在于总结这两种语言在语法上的不同点，对语法特性的原理不作深入探索和分析。希望对你有帮助。</p><hr><h1 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h1><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a><a href="https://docs.python.org/3/tutorial/introduction.html#numbers" target="_blank" rel="noopener">数值运算</a></h2><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>java整数除法运算结果只取<u><em>整数</em></u>部分</p><p>python整数除法运算总是返回<u><em>浮点数</em></u>,</p><p>python 使用<code>//</code>运算，对除法运算结果进行取整。</p><h3 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h3><p>java的幂运算需要使用<code>java.lang.Math</code>类的<code>pow(double,double)</code>方法</p><p>python直接使用运算符<code>**</code></p><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>java没有对复数的语法支持，需要自定义复数类</p><p>python有对复数的语法支持，如 <code>plu = 3+4j</code></p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a><a href="https://docs.python.org/3/tutorial/introduction.html#strings" target="_blank" rel="noopener">字符串操作</a></h2><p>java 用<code>&quot;&quot;</code>包含字符串常量，java中的字符串常量实质上是一个不可变的String对象，可以调用String对象的<code>length()</code>方法获取字符串常量的长度。</p><p>python可以用<code>&#39;&#39;</code> 和 <code>&quot;&quot;</code> 包含字符串常量，也可以用 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code> 和 <code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 包含多行文本。可以像操作字符数组一样操作python字符串，可以使用<u><em>负数索引</em></u>，表示从后往前索引。可以调用<u><em>内置函数</u></em><code>len()</code>获取字符串长度。python字符串还支持<u><em>切片</u></em>操作。</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>java 的基本条件控制语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</span><br><span class="line">    statements2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(conditionX)&#123;</span><br><span class="line">    statementsX;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    statementsDefault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 的基本条件控制语法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition :</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">elif</span> condition2 :</span><br><span class="line">    statements2</span><br><span class="line"><span class="keyword">elif</span> conditions3 :</span><br><span class="line">    statements3</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    statementsDefault</span><br></pre></td></tr></table></figure><p>另外 java 使用 <code>switch..case</code> 语法来控制多条件分支的情况，python 使用 <code>if..elif..elif</code> 处理多条件分支，同样很方便。</p><h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>java 中的 <code>for</code> 语句有两种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式二：</span></span><br><span class="line">String[] s1 = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String ss : s1)&#123;</span><br><span class="line">System.out.print(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python中 for 语句的语法形式为：<code>for item in iterators</code>，这跟 java 的“形式二”相似。其中有一点需要注意的是：如果 iterators 使用切片，则会对其进行一个浅拷贝,这样item每次就会取浅拷贝的内容进行处理。在循环中如果需要对iterators进行变更的，需要作浅拷贝处理。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words=[<span class="string">'this'</span>,<span class="string">'is'</span>,<span class="string">'python'</span>]</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words[:] :</span><br><span class="line">    <span class="keyword">if</span> len(word)&gt;<span class="number">2</span>:</span><br><span class="line">        words.insert(<span class="number">0</span>,word)</span><br><span class="line">print(words)</span><br></pre></td></tr></table></figure><p>以上代码的输出结果是：[‘python’, ‘this’, ‘this’, ‘is’, ‘python’]<br>现在把代码变成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words=[<span class="string">'this'</span>,<span class="string">'is'</span>,<span class="string">'python'</span>]</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words : <span class="comment">#注意这里的区别</span></span><br><span class="line">    <span class="keyword">if</span> len(word)&gt;<span class="number">2</span>:</span><br><span class="line">        words.insert(<span class="number">0</span>,word)</span><br><span class="line">print(words)</span><br></pre></td></tr></table></figure><p>以上代码将陷入死循环。</p><p>值得注意的是，python 提供了一个内置函数<code>range()</code>，它会按照规定的<em>范围</em>和<em>步长</em>生成一个序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(range(<span class="number">10</span>)) <span class="comment">#输出[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">list(range(<span class="number">3</span>,<span class="number">10</span>)) <span class="comment">#输出[3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">list(range(<span class="number">2</span>,<span class="number">30</span>,<span class="number">4</span>)) <span class="comment">#输出[2, 6, 10, 14, 18, 22, 26]</span></span><br></pre></td></tr></table></figure><p>python 的 for 语句还可以配合 else 使用，for循环中的语句没有执行<code>break</code>，则 else 语句将不会执行，反之亦然。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">     <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">             print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line">        print(n, <span class="string">'is a prime number'</span>)</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 is a prime number</span><br><span class="line">3 is a prime number</span><br><span class="line">4 equals 2 * 2</span><br><span class="line">5 is a prime number</span><br><span class="line">6 equals 2 * 3</span><br><span class="line">7 is a prime number</span><br><span class="line">8 equals 2 * 4</span><br><span class="line">9 equals 3 * 3</span><br></pre></td></tr></table></figure><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>java 中的函数定义很固定：<code>访问范围</code>+<code>是否静态</code>+<code>是否final</code>+<code>返回类型</code>+<code>函数名</code>+<code>（参数类型 参数名，参数类型2 参数名 ，...）</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//statements;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问范围</strong>：<code>public</code>，<code>private</code>，<code>protected</code> 和 <code>默认</code>（不指定则表示是默认的作用域，在同一个包内的类能够访问）<br><strong>是否静态</strong>：用<code>static</code>关键字申明，如果是‘static’，表示该方法为<code>类方法</code>，否则为<code>成员方法</code>。<br><strong>是否final</strong>：用<code>final</code>关键字申明，如果是‘final’，则表示该方法不可被继承。<br><strong>返回类型</strong>：返回类型可以是<code>void</code>，java定义9种简单数据类型，java类。</p><p>一般情况下，java 函数的参数都是固定的N(N&gt;=0)个参数，按照 <a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">effective java</a> 的建议，参数的个数最好不要超过4个。<br>当函数的所有参数都是同一个类型的时候，java 支持可变参数的申明形式，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//statements;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 中定义函数的语法形式为：<code>def</code>+<code>函数名</code>+<code>(参数,参数,...,参数=缺省值)</code>，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_ok</span><span class="params">(prompt, retries=<span class="number">4</span>, reminder=<span class="string">'Please try again!'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ok = input(prompt)</span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'y'</span>, <span class="string">'ye'</span>, <span class="string">'yes'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'n'</span>, <span class="string">'no'</span>, <span class="string">'nop'</span>, <span class="string">'nope'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        retries = retries - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid user response'</span>)</span><br><span class="line">        print(reminder)</span><br></pre></td></tr></table></figure><p>说明：python在定义函数的时候，函数的参数列表是可以指定缺省值的。当指定了缺省值，在调用函数的时候，指定缺省值的参数就成为了非必传参数了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式、模板方法模式、建造者模式在接口请求参数构造中的应用</title>
      <link href="/2017/03/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2017/03/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><font face="黑体" size=3 color="#DEB887">接口请求参数始终是两个固定的参数键值对：params=XXX，signature=xxx ，其中sianature的值是使用HMAC-SHA1算法对params参数进行签名得到的，params是对各个参数键值对经过xxTea进行加密得到。</font><br><br/></p><blockquote><p> 此时可以构造两个方法，一个方法用于生成signature，一个用于生成params。params的参数键值对每个接口不同，所有定义成抽象方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String appSecret=<span class="string">"21CHINATELEcnCOM"</span><span class="comment">//16位加密秘钥</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成请求参数signature</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSignature</span><span class="params">(<span class="keyword">long</span> timeStamp)</span></span>&#123;</span><br><span class="line">    String params = getParams(timeStamp);<span class="comment">//模板方法获取params参数</span></span><br><span class="line">    <span class="keyword">byte</span>[] hmacSHA1 = HMAC_SHA1.getHmacSHA1(params, appSecret);<span class="comment">//HMAC_SHA1对参数进行加密</span></span><br><span class="line">    String signature = HMAC_SHA1.bytesToHexString(hmacSHA1);</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *模板方法，由子类实现</span></span><br><span class="line"><span class="comment">     * 生成请求参数params</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getTestParams</span><span class="params">(<span class="keyword">long</span> timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  在请求参数params中，有一部分是所有接口都必传的公共类参数，有一部分是不同接口自定义的接口，那些公共的接口参数可以抽取到抽象方法的类里面，那些自定义的参数在各个子类中自定义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String appSecret=<span class="string">"21CHINATELEcnCOM"</span><span class="comment">//16位加密秘钥</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//公共参数放入父类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String version_no = <span class="string">"v1.0"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String versin_name = <span class="string">"v1.0"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String os = <span class="string">"1"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> appId = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String channel = <span class="string">"home"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String user_serial_no = <span class="string">"s_d163330629de366482ba133da990bdcb"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String imei = <span class="string">"m863077022374536"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成请求参数signature</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSignature</span><span class="params">(<span class="keyword">long</span> timeStamp)</span></span>&#123;</span><br><span class="line">    String params = getParams(timeStamp);<span class="comment">//模板方法获取params参数</span></span><br><span class="line">    <span class="keyword">byte</span>[] hmacSHA1 = HMAC_SHA1.getHmacSHA1(params, appSecret);<span class="comment">//HMAC_SHA1对参数进行加密</span></span><br><span class="line">    String signature = HMAC_SHA1.bytesToHexString(hmacSHA1);</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *模板方法，由子类实现</span></span><br><span class="line"><span class="comment">     * 生成请求参数params</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getTestParams</span><span class="params">(<span class="keyword">long</span> timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将公共类参数固定存放在父类抽象类中，自定一参数通过子类自定义</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">addCustomizedParams</span><span class="params">(Map&lt;String ,Object&gt; customized,<span class="keyword">long</span> timestamp)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Set&lt;String&gt; keySet = customized.keySet();</span><br><span class="line">    Iterator&lt;String&gt; its = keySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (its.hasNext()) &#123;</span><br><span class="line">       String key = its.next();</span><br><span class="line">       Object value = customized.get(key);</span><br><span class="line">       sb.append(key).append(<span class="string">"="</span>).append(value).append(<span class="string">"&amp;"</span>);<span class="comment">//将自定义参数加入公共参数中</span></span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">"timestamp="</span>).append(timestamp).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"imei="</span>).append(imei).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"os="</span>).append(os).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"user_serial_no="</span>).append(user_serial_no).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"app_id="</span>).append(appId).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"version_no="</span>).append(version_no).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"version_name="</span>).append(version_name).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"channel_name="</span>).append(channelName).append(<span class="string">"&amp;"</span>);</span><br><span class="line">    sb.append(<span class="string">"device_token="</span>).append(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对参数对进行加密</span></span><br><span class="line">    String encrypt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       encrypt = XXTea.encrypt(sb.toString(), <span class="string">"UTF-8"</span>, ByteFormat.toHex(appSecret.getBytes()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> encrypt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在有一类搜索相关的接口，需要传N个自定义参数，有一部分只需要其中的几个自定义参数，有一部分需要全部的自定义参数，此时刚好合适使用建造者模式来处理这类问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchParam</span> <span class="keyword">extends</span> <span class="title">TestParam</span> </span>&#123;</span><br><span class="line">  <span class="comment">//有N个自定义接口参数</span></span><br><span class="line">  <span class="keyword">private</span> String keyword;  <span class="comment">//所有搜索类接口都需要传这个参数</span></span><br><span class="line">  <span class="keyword">private</span> Integer isHotWord;</span><br><span class="line">  <span class="keyword">private</span> Integer searchType;</span><br><span class="line">  <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">  <span class="keyword">private</span> Integer pageSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SearchParam</span><span class="params">(String keyword,Integer isHotWord,Integer searchType,Integer pageNo,Integer pageSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.keyword = keyword;</span><br><span class="line">    <span class="keyword">this</span>.isHotWord = isHotWord;</span><br><span class="line">    <span class="keyword">this</span>.searchType = searchType;</span><br><span class="line">    <span class="keyword">this</span>.pageNo = pageNo;</span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个静态内部类作为外部类的建造者</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String keyword;</span><br><span class="line">    <span class="keyword">private</span> Integer isHotWord;</span><br><span class="line">    <span class="keyword">private</span> Integer searchType;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String keyword)</span></span>&#123;<span class="comment">//因为这是必传参数，所有在构造对象的时候就强制初始化</span></span><br><span class="line">      <span class="keyword">this</span>.keyword = keyword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">isHotWord</span><span class="params">(Integer isHotWord)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.isHotWord = isHotWord;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">searchType</span><span class="params">(Integer searchType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.searchType = searchType;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">pageNo</span><span class="params">(Integer pageNo)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.pageNo = pageNo;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">pageSize</span><span class="params">(Integer pageSize)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在建造者类中穿件外部类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SearchParam <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SearchParam(keyword,isHotWord,searchType,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTestParams</span><span class="params">(<span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">      params.put(<span class="string">"keyword"</span>, keyWord);</span><br><span class="line">      params.put(<span class="string">"is_hotword"</span>, isHotWord);</span><br><span class="line">      params.put(<span class="string">"search_type"</span>, searchType);</span><br><span class="line">      params.put(<span class="string">"page_no"</span>, pageNo);</span><br><span class="line">      params.put(<span class="string">"page_size"</span>, pageSize);</span><br><span class="line">      <span class="keyword">return</span> addCustomizedParams(params, timestamp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在需要一个参数生成器，通过它来生成URL形式的请求参数，这个构造器只需要在内存中保存一份实例供多个客户端程序使用就可以，所有此时可以使用单例模式来创建这个请求参数生成器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchParamGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SearchParamGenerator instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SearchParamGenerator</span><span class="params">(TestParam testParam)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.testParam = testParam;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SearchParamGenerator <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> SearchParamGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//生成请求参数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">genRequestParam</span><span class="params">(TestParam testParam)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    params = testParam.getTestParams(time);</span><br><span class="line">    sign = testParam.getTestSignature(time);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?params="</span> + params + <span class="string">"&amp;signature="</span> + sign;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>客户端程序通过如下方式使用参数生成器生成满足要求的参数：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">GenRequestParamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.构造请求参数类</span></span><br><span class="line">    <span class="comment">//例如我需要keyword，isHotword，searchType 三个请求参数</span></span><br><span class="line">    TestParam testParam = <span class="keyword">new</span> SearchParam.Builder(<span class="string">"关键字"</span>).isHotword(<span class="number">1</span>).type(<span class="number">2</span>).build();</span><br><span class="line">    <span class="comment">//我需要keyword，isHotWord,type，searchType,pageNo,pageSize</span></span><br><span class="line">    TestParam testaParam2 = <span class="keyword">new</span> SearchParam.Builder(<span class="string">"关键字2"</span>).isHotWord(<span class="number">0</span>).type(<span class="number">1</span>).searchType(<span class="number">2</span>).pageNo(<span class="number">1</span>).pageSize(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2.使用生成器生成请求参数</span></span><br><span class="line">    String requestParam1 = SearchParamGenerator.getInstance().genRequestParam(testParam);</span><br><span class="line">    String requestParam2 = SearchParamGenerator.getInstance().genRequestParam(testaParam2);</span><br><span class="line">    System.out.println(<span class="string">"requestParam1 : "</span>+requestParam1);</span><br><span class="line">    System.out.println(<span class="string">"requestParam2 : "</span>+requestParam2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概览之单例模式</title>
      <link href="/2016/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><p><strong>设计模式（Design Patterns）</strong>在软件开发中非常出名，一个设计模式很好的描述了一类通用的软件问题的解决方案。<br>以下是使用设计模式的一些好处：</p><ol><li>设计模式是已经设计好的提供一种工业化的标准方案解决通用的问题，所以直接使用它能节省很多时间。</li><li>使用设计模式提升了复用性，加强了代码的健壮性和可维护性，减少了软件产品的总体成本(TCO，total cost of ownership)。</li><li>使用设计模式是我们的代码更加容易理解和调试，让我们更快的开发新的模块，团队的新成员更快的理解现有的模块。</li></ol><p><strong>java设计模式</strong>可以被分为三类：<em>创建型<em>，</em>结构型<em>，</em>行为型</em></p><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>创建型设计模式能够在不同的应用场景上提供一种最好的方法来实例化一个对象。<br>基本的对象实例化很容易导致设计问题或者增加了设计上的不可预期的问题。创建型设计模式通过使用不同的方法来控制对象的创建，以解决上述问题。</p><p>这里会有五种创建型设计模式：</p><ol><li>单例模式（Singleton Pattern）</li><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>原型模式（Prototype Pattern）</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Singleton 是GoF设计模式中的一种。从定义上看，它似乎是一种非常简单的设计模式，但它有很多种不同的实现方式。<br>单例模式约束了类的实例化过程，确保java虚拟机中只有一个实例存在。单例模式类必须提供一个全局访问点来获取到这个类的实例。单例模式一般运用于日志、驱动对象、缓存和线程池。<br>单例模式一般也用于其他的设计模式如抽象工厂模式、建造者模式、原型模式、外观模式等。它还被用于核心java类中如java.lang.Runtime ,java.awt.Desktop。<br>我们有很多方法实现单例模式，但它们都有以下共同的特点：</p><ul><li>一个私有的构造器防止别的类创建它的实例。</li><li>一个私有的成员变量，变量的类型为这个类本身，它是这个类唯一的实例对象。</li><li>一个静态的public方法返回这个类的实例，它就是外部世界访问这个类实例的全局访问点。<br>接下来，提供几个不同的单例模式实现方式，以及它们各自需要注意的地方</li></ul><p><strong>A.饿汉模式（Eager Initialization）</strong><br>饿汉模式在类加载的时候就创建它的实例对象，这是创建单例类最简单的一种方式。但是它有一个缺点就是客户端程序可能永远不会用到它的实例，这样造成了资源的浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitializationSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerInitializationSingleton instance = <span class="keyword">new</span> EagerInitializationSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerInitializationSingleton</span><span class="params">()</span></span>&#123;<span class="comment">//private constructor to avoid client applications to use constructor</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerInitializationSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果单例类没有使用太多资源，这倒是一种可行的实现方式。但在大多数情境下，单例类的创建需要很多资源如文件系统资源，数据库连接等等。合适的方式是在客户端程序使用getInstance方法的时候再创建类的实例。同时，饿汉模式也没有提供异常处理的地方。</p><p><strong>B.静态代码块初始化（Static Block Initialization）</strong><br>静态代码块初始化的方式与饿汉模式很相似，但前者能够在静态代码块中进行异常处理操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlockInitializaitionSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticBlockInitializaitionSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticBlockInitializaitionSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> StaticBlockInitializaitionSingleton();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">"Exception occured in creating singleton instance. "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticBlockInitializaitionSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种实现方式都是在使用类的实例之前就实例化了，这不是一种实用的实现方式。</p><p><strong>C.懒汉模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitializedSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInitializedSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitializedSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitializedSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazyInitializedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种实现方式在单线程环境中能正常的工作，但在多线程环境下就可能导致一些问题，如果同时有两个线程进入if语句中，就会使得两个线程得到不同的实例。</p><p><strong>D.线程安全的单例模式</strong><br>这种方式很简单创建出线程安全的单例模式，通过使用 <em>synchronized</em>关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadSafeSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ThreadSafeSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ThreadSafeSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现方式解决了线程安全的问题，但是因为同步方法的通信使得性能下降。为了避免这种额外的开销，一般使用双重检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeSingleton <span class="title">getInstanceUsingDoubleLocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ThreadSafeSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>E.Bill Pugh Singleton</strong><br>在java 5 之前，java的内存模型存在很多问题，当大量的线程同一时间请求单例类的实例时会出现一些问题。所以Bill Pugh 想出了一种不通的方式创建单例类：使用静态内部帮助类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BillPughSingleton INSTANCE = <span class="keyword">new</span> BillPughSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstacne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：private static class包含了单例类的实例。当单例类加载的时候，<em>SingletonHelper</em>还没有加载，仅仅当有人调用 <em>getInstance</em>方法的时候，这个类才加载并且创建单例类的实例。<br>这种方法被最广泛的使用，因为它不需要使用同步代码块。</p><p><strong>F.使用反射可以破环单例模式</strong><br>使用反射能够破坏上面提到的所有单例模式的实现方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionSingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EagerInitializationSingleton instance1 = EagerInitializationSingleton.getInstance();</span><br><span class="line">        EagerInitializationSingleton instance2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt;[] declaredConstructors = EagerInitializationSingleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructors</span>()</span>;</span><br><span class="line">            <span class="keyword">for</span> (Constructor constructor : declaredConstructors)&#123;</span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                instance2 = (EagerInitializationSingleton)constructor.newInstance();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法示例说明单例模式可以被反射破坏。<em>反射</em>一般用于框架的设计。  </p><p><strong>G.Enum Singleton</strong><br>为了克服反射的影响，可以使用枚举实现单例模式，确保了每个枚举值在java程序里只被实例化一次。它的缺点是不太灵活，例如，它不允许懒加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>H.Serialization and Singleton</strong><br>有时候在分布式系统中，我们需要为单例类实现序列化接口以便我们能将它的状态存储到文件系统，然后在某个点恢复它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1247620444544158772L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializedSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializedSingleton INSTANCE = <span class="keyword">new</span> SerializedSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面序列化单例类存在的问题是，反序列化这个类它的时候，总是会创建一个新的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tisa.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tisa on 2016/7/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonSerializedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        SerializedSingleton instance = SerializedSingleton.getInstance();</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"filename.ser"</span>));</span><br><span class="line">        objectOutputStream.writeObject(instance);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"filename.ser"</span>));</span><br><span class="line">        SerializedSingleton instance2 = (SerializedSingleton) objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也破坏了单例模式，为了避免这种情景，我们只需要提供一个readResolve()方法实现就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 设计模式 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员修炼之道</title>
      <link href="/2016/08/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/"/>
      <url>/2016/08/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看了程序员《修炼三部曲》，意识到一个人在任何领域内成长的快慢，跟一个人的思维方式有巨大的关系。资深人士，面对领域内的任何问题，能够通过一种<code>直觉效应</code>，迅速找到问题的突破口，并快速学习新知识，带领团队以最快速度解决。<br>这种<code>直觉效应</code>，是在正确的思维方式下，不断积累出来的内在能力。职场菜鸟，在经验不充足的时候，应该首先找到正确的思维方式，在正确的道路上行走，才能迅速到底目的地。</p><h1 id="注重实效"><a href="#注重实效" class="headerlink" title="注重实效"></a><strong>注重实效</strong></h1><p>1.不要找借口，找解决问题的方案。</p><p>2.破窗户理论。不要放任坏的-即使是微不足道的事情发生，它很有可能迅速爆发成很大的灾祸。</p><p>3.怎样获取资源，先让自己掌握的资源具有足够的吸引力；怎样让事情持续性增长，不要被煮青蛙，时刻关注变化。</p><p>4.在完成需求的基础上，让软件变得更好，而不是追求极致。</p><p>5.让知识持续不断的更新，学习新的语言，阅读技术书籍，参加技术活动，解决技术问题等等。面对挑战。</p><h1 id="实效的实践"><a href="#实效的实践" class="headerlink" title="实效的实践"></a><strong>实效的实践</strong></h1><p>6.don’t repeat yourself.</p><p>7.尽量让功能组件保持独立，少依赖与其他模块。</p><p>8.快速制作出原型。搭建用户需要的外在模型，加一些测试数据，让功能尽快的跑起来。</p><h1 id="编程态度"><a href="#编程态度" class="headerlink" title="编程态度"></a><strong>编程态度</strong></h1><p>1.始终将精力和注意放在要解决的问题上面，让整个团队的武器都指向问题的核心部位，其他的一切行为例如指责别人的错误，消极的态度，侥幸的心理，都是阻碍事情发展的，都是应该摒除的。</p><p>2.要始终保持代码的整洁度，不要添加一些难以理解的代码。</p><p>3.团队讨论方案的时候，应该先从正面思考他人提出的方案，该方案能解决什么问题，有哪些值得借鉴的地方，其次再思考该方案疏忽了哪些问题，会有什么缺陷。在提出自己观点或者反驳他人观点的时候，一定是对事不对人。</p><p>4.有勇气提出质疑，有勇气主动承担责任。</p><h1 id="学无止境"><a href="#学无止境" class="headerlink" title="学无止境"></a>学无止境</h1><p>5.每天安排固定的时间学习一些新的技术，小步前进。</p><p>6.经常进行技术分享，或者参加技术分享会议，倾听他人的见识以及分享自己知道的东西。</p><p>7.在学习新的技术的同时，要不断回头审视自己已经掌握的知识是不是已经不合时宜了，该丢掉的破铜烂铁果断丢弃掉，只保留那些对我们有用的东西，毕竟空间是有限的。</p><p>8.在接触任何一项不熟悉的事物的时候，面对自己的困惑，一定不要让困惑被似是而非所掩埋，要问为什么会是这样，并且努力找到满意的答案。</p><p>9.进行有节奏的小步前进，一口气吃不成一个胖子。每天前进一小步，时间会帮助你到达目的地。</p><h1 id="目标驱动"><a href="#目标驱动" class="headerlink" title="目标驱动"></a>目标驱动</h1><p>10.对于业务方面的需求，开发人员最好和业务人员达成共识，而不是从技术实现的角度擅自做出决定。对于不属于自己职责范围内的事情，让更加擅长的人做出决定。</p><p>11.不应该过度的设计，设计是指导编码的方向，而不是限制编码的条款。设计是计划，编码是实施计划。计划本身没有用，但制定计划的过程必不可少。</p><p>12.善于从各种成熟的技术框架和组件中辨别和挑选出对项目有真正作用的，不要重复的造轮子，不要重新开发那些已经具有良好实现的功能组件。</p><p>13.始终让项目处于可发布可运行的状态，团队开发中保持代码的一致性。小步迭代前进。</p><p>14.频繁的集成，使用单元测试让小的功能组件可以正确运行，集成到大的系统之中，让整个系统也可以正常运行。</p><h1 id="敏捷反馈"><a href="#敏捷反馈" class="headerlink" title="敏捷反馈"></a>敏捷反馈</h1><p>15.以测试作为驱动开发(TDD)，编写出有用的测试用例。</p><p>16.按照某种规则的优先级排列出任务列表，完成一个任务就将其从任务列表中去除。</p><h1 id="敏捷编码"><a href="#敏捷编码" class="headerlink" title="敏捷编码"></a>敏捷编码</h1><p>17.让代码自己说明意图，而不过度依赖与文档和注释。</p><p>18.要动态的评估和权衡取舍，设计、性能、成本之间应该做出权衡，要找到最重要的方面。</p><p>19.快速迭代开发，没开发一个小的功能模块，进行一次快速的测试，保证每一个模块都能正常良好的运行。</p><p>20.保持简单，在能表达出所有功能需求的同时，能够在代码上保持简洁，不过分设计，不过早的优化。</p><p>21.高内聚性的设计，考虑到各个功能模块或组件的粒度，不能过小，也不能是大杂烩的无所不包。</p><h1 id="敏捷调试"><a href="#敏捷调试" class="headerlink" title="敏捷调试"></a>敏捷调试</h1><p>22.记录下错误，以及解决方案。</p><p>23.各个击破问题，隔离组件单独查找问题，而不是把组件放在整个系统环境下排查<br>。<br>24.尽量处理异常，不能处理的异常则抛出给调用者，处理异常处尽量有日志记录。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员思想修炼 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建基于github和hexo的个人博客</title>
      <link href="/2016/04/12/%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Egithub%E5%92%8Chexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/04/12/%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Egithub%E5%92%8Chexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>这两个星期一直在倒腾博客的事情，从一开始想自己搭建前后端，自己租赁服务器，自己买域名，到突然从网上惊喜的发现，github可以提供足以满足我需求的所有东西（拥有自己标签的域名、几百M的网络空间、自由的发布和修改等等）。于是开始在网上找相关资料，虽然是技术出身，但是对“搭建博客”这件事情还处于懵懂阶段，说起来挺惭愧的，花了一周时间，终于搞清楚其中的来龙去脉。回过头来梳理梳理，发现其实挺简单的。只要熟悉了这个过程，按照步骤来做，一小时差不多就可以从零到完成框架的搭建，并发布到github上去。只是这个从入门到理解的过程，确实是需要时间消化的。学习任何知识都有这样的一个过程，<em>知其然，而后知其所以然</em>。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>要完成一件事情，首先想到的是，有没有什么工具可以帮忙做到，如果有，那这个工具在完成这件事情的过程中，充当了什么样的角色？先搞清楚这个，第二步就是花点时间学习一下这个工具的基本用法（这个阶段只需要了解基本用法就足够了，以后有有时间再深入研究，明白它运行的机制）。就搭建博客这件事情来说，需要用到两个工具，一个是github和hexo。</p><p>github可以理解为一个放博客的服务器，这个服务器有两个用途，一个是存放你的博客文件，一个是提供地址给外部访问。<br>hexo就是针对博客本身的。想一想，你做的个人博客，是不是也由两个部分组成？第一个部分是你写的文章，第二个部分是你把这些文章通过某个固定的框架排列整合（比如提供一个博客目录，提供分享的功能、提供评论的功能、给博客加标签等等）。hexo要做的事情就是提供给你一个这样的框架，你把文章放进去，它就能以你想要的某种方式生成一个具有固定样式框架的博客网站。<br>最后你要做的事情就是，将hexo生成好的博客网站发布到github上面去。<br>接下来，我们就按照上面说的思路开始完成我们的博客创建吧~</p><hr><ul><li><strong>github相关的环境搭建</strong></li></ul><p>1） 登陆<a href="https://github.com/" target="_blank" rel="noopener">github</a>网站，完成账号的注册和登录。<br/><br>2） 新建一个github仓库<code>new repository</code>，仓库名称是：<code>username.github.io</code>(username是你自定义的)，这个仓库就是你将来要存放由hexo帮你生成的博客框架的地方。<br/><br>3） 通过本地客户端连接到github网站，此时我们需要下载一个叫git的客户端软件，登陆<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>，下载最新版本的git客户端，按照步骤安装完成就可以了。安装完成后，在你的电脑桌面点击鼠标右键，会看到三个陌生的选项（Git init here ， git gui ， git bash），我们只需要点击git bash，就可以打开git的命令行窗口了。<br/><br>4）通过<code>git bash</code>连接github，在<code>git bash</code>中运行下列命令：<br/></p><p>a）    检查计算机ssh密钥</p><pre><code>$ cd ~/.ssh    </code></pre><p>b)    如果没有提示:No such file or directory 说明你不是第一次使用git,执行下面的操作,清理原有ssh密钥.</p><pre><code>$ ls      /config id_rsa id_rsa.pub known_hosts/ $ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa*</code></pre><p>c)    获得密钥：</p><pre><code>ssh-keygen -t rsa -C &quot;defnngj@gmail.com&quot;//填写email地址，然后一直“回车”ok</code></pre><p>如果提示：Hi defnngj You’ve successfully authenticated, but GitHub does not provide shell access. 说明你连接成功了。</p><p>d)    设置用户信息:</p><pre><code>$ git config --global user.name &quot;tisakong&quot;//给自己起个用户名$ git config --global user.email  &quot;tisakong@163.com&quot;//填写自己的邮箱</code></pre><p>e)    在用户目录下，找到<code>id_rsa.pub</code>这个文件,用文本方式打开。文本内容类似：</p><pre><code>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDJPNg7CO71a9EksZC1Soevszec5YaYYmBwnRwHMSL5P2lcQfrMkBtF6y5rM5H95JGjueik4sTKIldLrAnyPOutfiy7ItURzXSirkrlitsBVX2Bp/tCqKHTFfJb9NFzzjL/IAr2sPkkQHwB94BC0ulk4l+GXrGXocWP+uhkK7l1yW5lsb0+kcJH2OvI07pjp4V/SIgIUf0QylBy/6ERTW6owUHSp1EXhUmWT4HmDfUtdgIB/gqOMEp4mWxCZlj1AusGmdyC14Rv8W/f0+Ofe+/wtqu+78zzNHg7+dmLp2t3DpdxxxxtH1onlL4Hk2Q/eU7LyJD6YbXE4hmmgqz1enN9 tisakong@163.com</code></pre><p>f)    登陆到github网站，打开<a href="https://gi thub.com/settings/profile" target="_blank" rel="noopener">个人设置</a>页面，找到<code>SSH and GPG keys</code>选项，点击右上方<code>New SSH key</code>,将e)中打开的文本内容复制到<code>key输入框</code>中。</p><p>g)    测试一下能否连上，使用<code>git clone</code> 命令从github仓库拷贝一份项目到本地:</p><pre><code>git clone https://github.com/spring-projects/spring-framework</code></pre><p>如果可以连上，则会显示命令行工具会显示下载进度。</p><p>至此，与git相关的环境就算搭建完成了。</p><ul><li><strong>hexo相关的环境搭建</strong></li></ul><p>1） 因为hexo是基于<code>nodejs</code>的一个框架组件，所以必须先在电脑上安装<code>nodejs</code>的环境，登陆<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a>，下载最新版本的nodejs，按照提示安装即可，完成后，打开命令行工具，输入<code>node -v</code> 验证是否安装成功。如果显示版本号信息，说明安装成功。<br/><br>2） 在<code>git bash</code>命令行工具中安装hexo组件，输入</p><pre><code>`npm install -g hexo`</code></pre><p>3） 新建一个存放博客目录的文件夹，如blog，进入到该文件夹,运行hexo命令</p><pre><code>$ cd /blog$ hexo init $ npm install</code></pre><p>到这里，一个空的博客框架就生成了。注意，以后的所有操作都是在blog这个文件夹里面执行的。</p><p>4） 写博客</p><pre><code>$ hexo new [layout] &lt;title&gt;例如 hexo new 我的第一篇博客</code></pre><p>这个操作，会在<br>5） 生成静态页面</p><pre><code>hexo generate   //可简写为 hexo g</code></pre><p>至此，博客框架和第一个博客就完成了。<br>详细的教程，参见<a href="https://hexo.io" target="_blank" rel="noopener">hexo官网</a>。</p><ul><li><strong>将hexo博客框架部署到github中</strong></li></ul><p>1） 在blog文件夹中找到<code>_config.yml</code>文件，在最下面一行找到deploy栏目，并修改成：</p><pre><code>deploy:      type: git      repository: git@github.com:github_username/username.github.io.git      branch: master    //注意：        //1.github_username是你github网站的用户名，username是你仓库名保持一致。    //2.冒号：后面要加空格</code></pre><p>2）    发布到github，执行：</p><pre><code>$ hexo deploy  //可简写为 hexo d</code></pre><p>3）    每次发布新文章，重新部署的时候，一次执行下面命令即可：</p><pre><code>$ hexo clean$ hexo generate$ hexo deploy</code></pre><p>4)    至此，所有的基本步骤就都完成了，在浏览器访问username.github.io看看效果吧。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h2><p>学习每一个新事物，如果按照如下三个步骤来做，都是很快就能从入门到精通吧！</p><pre><code>1.理清有哪些主体对象。2.搞清楚每个主体之间有什么逻辑关联。3.不断尝试。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
